{"componentChunkName":"component---src-templates-blog-page-js","path":"/tutorials/using-arel-for-unions/","result":{"data":{"markdownRemark":{"html":"<p>Recently, I ran into a situation where I had two different Models where I needed to display both types of records in chronological order. We could grab all the records, and apply a simple sort.</p>\n<pre><code class=\"language-ruby\">  comments = Comment.active.to_ary\r\n  posts = Post.active.to_ary\r\n\r\n  # Combine them together and sort.\r\n  comments_and_posts = comments + posts\r\n  comments_and_posts.sort! { |a, b| a.created_at &#x3C;=> b.created_at }\r\n\r\n  # Use Kaminari to paginate across\r\n  results = Kaminari.paginate(comments_and_posts).page(params[:page])\n</code></pre>\n<p>While this is easy to read and understand, this is problematic as Comments and Posts grows. This method would require grabbing all the records before applying a sorted order. Pagination is also affected poorly, since we still need to grab both entire sets of records.</p>\n<p>We can leverage the database to handle the sorting for us, but Rails does not have a pretty ORM way in the documentation to perform this kind of operation. We can use plain SQL.</p>\n<h2>Raw SQL Union</h2>\n<p>We use the UNION operator in SQL to combine both records together, then select from a subquery.</p>\n<p>Since there is a possibility that ids are shared between the models, we need to generate a <code>unique_id</code> in these queries.</p>\n<pre><code class=\"language-sql\">\r\nSELECT id, group_type, unique_id, created_at\r\nFROM (\r\n  SELECT id,\r\n        'comments' group_type,\r\n        CONCAT('comments', id) as unique_id,\r\n        created_at\r\n  FROM comments\r\n  WHERE active = 1\r\n\r\n  UNION\r\n\r\n  SELECT id,\r\n         'posts' group_type,\r\n         CONCAT('posts', id) as unique_id,\r\n         created_at\r\n  FROM posts\r\n  WHERE active = 1\r\n) as results\r\n\r\nORDER BY created_at desc\r\n--LIMIT 25 OFFSET 200\n</code></pre>\n<p>We can add a <code>LIMIT</code> and <code>OFFSET</code> to use as pagination. Using a raw SQL query, we can pull out the information easily.</p>\n<pre><code class=\"language-ruby\">@connection = ActiveRecord::Base.connection\r\nresult = @connection.exec_query(sql_query)\r\ncomments_and_posts = []\r\n\r\nresult.each do |row|\r\n  comments_and_posts &#x3C;&#x3C; row\r\nend\n</code></pre>\n<p>While we can go through each row in comments and posts and find by ID, that would give us about 25 additional queries. We can do a little extra work to reduce the amount of queries down to 2.</p>\n<pre><code class=\"language-ruby\"># Store their order in the array.\r\nid_positions = comments_and_posts.map { |x| x['unique_id'] }\r\n\r\nitems = comments_and_posts.group_by { |x| x['group_type'] }\r\nitems.each do |group_type, item|\r\n\r\n  # Get only the ids to reduce amount of queries needed\r\n  ids = item.collect { |x| x['id'] }\r\n\r\n  if group_type == 'posts'\r\n    content_items = Post.where(id: ids).to_ary\r\n  elsif group_type == 'comments'\r\n    content_items = Comment.where(id: ids).to_ary\r\n  end\r\n\r\n  # Replace original search with new searched content\r\n  content_items.each do |content|\r\n    unique_id = group_type + content.id.to_s\r\n    content_index = id_positions.index(unique_id)\r\n    comments_and_posts[content_index] = content\r\n  end\r\nend\r\n\r\ncomments_and_posts\n</code></pre>\n<h2>Drawbacks to Raw SQL</h2>\n<p>By diving into Raw SQL, we have direct control of what to query. For smaller queries, this is manageable.</p>\n<p>We lose some key features, like scopes. Scopes are composable, and simplifies our understanding of queries. We would have to maintain a separate set of queries if we decide to add filtering.</p>\n<p>Raw SQL is also reliant on having a specific flavor of SQL. If we decide to switch MySQL to Postgres, some queries would change and break.</p>\n<h2>Using Arel to access existing scopes</h2>\n<p>We're looking to use ActiveRecord's Arel, to improve our codebases readability. Note: Since this is a private API, it may change without warning. It is expected that Arel becomes part of public API in Rails 5.1.</p>\n<p>We can replace the raw SQL using Arel as a Query Builder. For ActiveRecord::Relation query, we can call <code>.arel</code> to drop into Arel.</p>\n<h2>Rewriting SQL into Arel Components</h2>\n<p>Since Arel is used to build queries only, we'll end up transforming the resulting query builder to a SQL String with <code>.to_sql</code>.</p>\n<p>So we're going to create each part of our query piece by piece.</p>\n<pre><code class=\"language-ruby\">\r\ncomments_query = Comment.active.arel\r\n# Strip all the SELECT choices\r\ncomments_query.projections = []\r\n\r\n# Select our items that we need\r\ncomments_query.projections('comments.id as id',\r\n                    'CONCAT(\"comments\", comments.id) as unique_id',\r\n                    'comments.created_at',\r\n                    '\"comments\" as group_type')\r\n\r\n# comments_query.to_sql generates\r\n\r\n# SELECT\r\n#   id,\r\n#   'comments' group_type,\r\n#   CONCAT('comments', id) as unique_id,\r\n#   created_at\r\n# FROM comments\r\n# WHERE active = 1\r\n\r\nposts_query = Post.active.arel\r\nposts_query.projections = []\r\nposts_query.projections('posts.id as id',\r\n                  'CONCAT(\"posts\", posts.id) as unique_id',\r\n                  'posts.created_at',\r\n                  '\"posts\" as group_type')\r\n\r\n# post_query.to_sql generates\r\n\r\n# SELECT\r\n#   id,\r\n#   'posts' group_type,\r\n#   CONCAT('posts', id) as unique_id,\r\n#   created_at\r\n# FROM posts\r\n# WHERE active = 1\r\n\n</code></pre>\n<p>We can then combine both of the queries together with a UNION.</p>\n<pre><code class=\"language-ruby\">combined_query = comments_query.union(:all, posts_query)\r\n\r\n# (#{comments_query} UNION #{posts_query})\r\n\r\nquery = Arel::SelectManager.new(Arel::Table.engine, Arel.sql(\"#{combined_query.to_sql} as results\"))\r\n\r\n# (#{comments_query} UNION #{posts_query}) as results\r\n\n</code></pre>\n<p>Calling <code>Arel::SelectManager.new(Arel::Table.engine, sql_string)</code> gives us the equivalent of wrapping up <code>combined_query</code> into a subquery.</p>\n<pre><code class=\"language-ruby\">limit = 25\r\noffset = 0\r\nsql = query.project(Arel.star)\r\n           .order(\"created_at DESC\")\r\n           .take(limit)\r\n           .skip(offset).to_sql\r\n\r\n# SELECT * FROM (#{comments_query} UNION #{posts_query}) as results\r\n# ORDER BY created_at DESC\r\n# LIMIT 25\r\n# OFFSET 0\r\n\r\nresults = ActiveRecord::Base.connection.select_all(sql)\n</code></pre>","frontmatter":{"title":"Sorting between multiple Models in Ruby on Rails","date":"12 January, 2017"}}},"pageContext":{"slug":"/tutorials/using-arel-for-unions/"}},"staticQueryHashes":[]}