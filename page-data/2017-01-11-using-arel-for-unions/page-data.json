{"componentChunkName":"component---src-templates-blog-page-js","path":"/2017-01-11-using-arel-for-unions/","result":{"data":{"markdownRemark":{"id":"6250b3db-b4a6-5f22-94d5-eccc1a1ad13a","html":"<p>Recently, I ran into a situation where I had two different Models where I needed to display both types of records in chronological order. We could grab all the records, and apply a simple sort.</p>\n<pre><code class=\"language-ruby\">  comments = Comment.active.to_ary\n  posts = Post.active.to_ary\n\n  # Combine them together and sort.\n  comments_and_posts = comments + posts\n  comments_and_posts.sort! { |a, b| a.created_at &#x3C;=> b.created_at }\n\n  # Use Kaminari to paginate across\n  results = Kaminari.paginate(comments_and_posts).page(params[:page])\n</code></pre>\n<p>While this is easy to read and understand, this is problematic as Comments and Posts grows. This method would require grabbing all the records before applying a sorted order. Pagination is also affected poorly, since we still need to grab both entire sets of records.</p>\n<p>We can leverage the database to handle the sorting for us, but Rails does not have a pretty ORM way in the documentation to perform this kind of operation. We can use plain SQL.</p>\n<h2>Raw SQL Union</h2>\n<p>We use the UNION operator in SQL to combine both records together, then select from a subquery.</p>\n<p>Since there is a possibility that ids are shared between the models, we need to generate a <code>unique_id</code> in these queries.</p>\n<pre><code class=\"language-sql\">SELECT id, group_type, unique_id, created_at\nFROM (\n  SELECT id,\n        'comments' group_type,\n        CONCAT('comments', id) as unique_id,\n        created_at\n  FROM comments\n  WHERE active = 1\n\n  UNION\n\n  SELECT id,\n         'posts' group_type,\n         CONCAT('posts', id) as unique_id,\n         created_at\n  FROM posts\n  WHERE active = 1\n) as results\n\nORDER BY created_at desc\n--LIMIT 25 OFFSET 200\n</code></pre>\n<p>We can add a <code>LIMIT</code> and <code>OFFSET</code> to use as pagination. Using a raw SQL query, we can pull out the information easily.</p>\n<pre><code class=\"language-ruby\">@connection = ActiveRecord::Base.connection\nresult = @connection.exec_query(sql_query)\ncomments_and_posts = []\n\nresult.each do |row|\n  comments_and_posts &#x3C;&#x3C; row\nend\n</code></pre>\n<p>While we can go through each row in comments and posts and find by ID, that would give us about 25 additional queries. We can do a little extra work to reduce the amount of queries down to 2.</p>\n<pre><code class=\"language-ruby\"># Store their order in the array.\nid_positions = comments_and_posts.map { |x| x['unique_id'] }\n\nitems = comments_and_posts.group_by { |x| x['group_type'] }\nitems.each do |group_type, item|\n\n  # Get only the ids to reduce amount of queries needed\n  ids = item.collect { |x| x['id'] }\n\n  if group_type == 'posts'\n    content_items = Post.where(id: ids).to_ary\n  elsif group_type == 'comments'\n    content_items = Comment.where(id: ids).to_ary\n  end\n\n  # Replace original search with new searched content\n  content_items.each do |content|\n    unique_id = group_type + content.id.to_s\n    content_index = id_positions.index(unique_id)\n    comments_and_posts[content_index] = content\n  end\nend\n\ncomments_and_posts\n</code></pre>\n<h2>Drawbacks to Raw SQL</h2>\n<p>By diving into Raw SQL, we have direct control of what to query. For smaller queries, this is manageable.</p>\n<p>We lose some key features, like scopes. Scopes are composable, and simplifies our understanding of queries. We would have to maintain a separate set of queries if we decide to add filtering.</p>\n<p>Raw SQL is also reliant on having a specific flavor of SQL. If we decide to switch MySQL to Postgres, some queries would change and break.</p>\n<h2>Using Arel to access existing scopes</h2>\n<p>We're looking to use ActiveRecord's Arel, to improve our codebases readability. Note: Since this is a private API, it may change without warning. It is expected that Arel becomes part of public API in Rails 5.1.</p>\n<p>We can replace the raw SQL using Arel as a Query Builder. For ActiveRecord::Relation query, we can call <code>.arel</code> to drop into Arel.</p>\n<h2>Rewriting SQL into Arel Components</h2>\n<p>Since Arel is used to build queries only, we'll end up transforming the resulting query builder to a SQL String with <code>.to_sql</code>.</p>\n<p>So we're going to create each part of our query piece by piece.</p>\n<pre><code class=\"language-ruby\">comments_query = Comment.active.arel\n# Strip all the SELECT choices\ncomments_query.projections = []\n\n# Select our items that we need\ncomments_query.projections('comments.id as id',\n                    'CONCAT(\"comments\", comments.id) as unique_id',\n                    'comments.created_at',\n                    '\"comments\" as group_type')\n\n# comments_query.to_sql generates\n\n# SELECT\n#   id,\n#   'comments' group_type,\n#   CONCAT('comments', id) as unique_id,\n#   created_at\n# FROM comments\n# WHERE active = 1\n\nposts_query = Post.active.arel\nposts_query.projections = []\nposts_query.projections('posts.id as id',\n                  'CONCAT(\"posts\", posts.id) as unique_id',\n                  'posts.created_at',\n                  '\"posts\" as group_type')\n\n# post_query.to_sql generates\n\n# SELECT\n#   id,\n#   'posts' group_type,\n#   CONCAT('posts', id) as unique_id,\n#   created_at\n# FROM posts\n# WHERE active = 1\n</code></pre>\n<p>We can then combine both of the queries together with a UNION.</p>\n<pre><code class=\"language-ruby\">combined_query = comments_query.union(:all, posts_query)\n\n# (#{comments_query} UNION #{posts_query})\n\nquery = Arel::SelectManager.new(Arel::Table.engine, Arel.sql(\"#{combined_query.to_sql} as results\"))\n\n# (#{comments_query} UNION #{posts_query}) as results\n</code></pre>\n<p>Calling <code>Arel::SelectManager.new(Arel::Table.engine, sql_string)</code> gives us the equivalent of wrapping up <code>combined_query</code> into a subquery.</p>\n<pre><code class=\"language-ruby\">limit = 25\noffset = 0\nsql = query.project(Arel.star)\n           .order(\"created_at DESC\")\n           .take(limit)\n           .skip(offset).to_sql\n\n# SELECT * FROM (#{comments_query} UNION #{posts_query}) as results\n# ORDER BY created_at DESC\n# LIMIT 25\n# OFFSET 0\n\nresults = ActiveRecord::Base.connection.select_all(sql)\n</code></pre>","frontmatter":{"title":"Sorting between multiple Models in Ruby on Rails","date":"12 January, 2017"}}},"pageContext":{"slug":"/2017-01-11-using-arel-for-unions/"}}}